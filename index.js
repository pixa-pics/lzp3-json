/*
GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year  name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
*/

// 97% SOURCE: https://github.com/eladkarako/compressjs-flattened/blob/master/Lzp3_joined_.js

const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
window.lzp3_json_process_function = AsyncFunction(`var fu=async function(t,e){return new Promise((function(r,i){"use strict";var s,o,n,h,a,u,f,c,p,d;s=function(){var t=Math.pow(2,31),e=t>>>8,r=Math.pow(2,32)-1,i=function(e){this.low=0,this.range=t,this.buffer=0,this.help=0,this.bytecount=0,this.stream=e},s=function(i,s){for(;i.range<=e;){if(i.low<255<<23){for(s.writeByte(i.buffer);i.help;i.help--)s.writeByte(255);i.buffer=i.low>>>23&255}else if(i.low&t){for(s.writeByte(i.buffer+1);i.help;i.help--)s.writeByte(0);i.buffer=i.low>>>23&255}else if(i.help++,i.help>r)throw new Error("Too many bytes outstanding, file too large!");i.range=i.range<<8>>>0,i.low=(i.low<<8&t-1)>>>0,i.bytecount++}};i.prototype.encodeStart=function(e,r){this.low=0,this.range=t,this.buffer=e,this.help=0,this.bytecount=r},i.prototype.encodeFreq=function(t,e,r){s(this,this.stream);var i=this.range/r>>>0,o=i*e;this.low+=o,e+t<r?this.range=i*t:this.range-=o},i.prototype.encodeShift=function(t,e,r){s(this,this.stream);var i=this.range>>>r,o=i*e;this.low+=o,e+t>>>r?this.range-=o:this.range=i*t},i.prototype.encodeBit=function(t){this.encodeShift(1,t?1:0,1)},i.prototype.encodeByte=function(t){this.encodeShift(1,t,8)},i.prototype.encodeShort=function(t){this.encodeShift(1,t,16)},i.prototype.encodeFinish=function(){var t=this.stream;s(this,t),this.bytecount+=5;var r=this.low>>>23;if((this.low&e-1)>=(16777215&this.bytecount)>>>1&&r++,r>255)for(t.writeByte(this.buffer+1);this.help;this.help--)t.writeByte(0);else for(t.writeByte(this.buffer);this.help;this.help--)t.writeByte(255);return t.writeByte(255&r),t.writeByte(this.bytecount>>>16&255),t.writeByte(this.bytecount>>>8&255),t.writeByte(255&this.bytecount),this.bytecount},i.prototype.decodeStart=function(t){var e=t?0:this.stream.readByte();return"number"!=typeof e||e<0||(this.buffer=this.stream.readByte(),this.low=this.buffer>>>1,this.range=128),e};var o=function(t,r){for(;t.range<=e;)t.low=t.low<<8|t.buffer<<7&255,t.buffer=r.readByte(),t.low|=t.buffer>>>1,t.low=t.low>>>0,t.range=t.range<<8>>>0};return i.prototype.decodeCulFreq=function(t){o(this,this.stream),this.help=this.range/t>>>0;var e=this.low/this.help>>>0;return e>=t?t-1:e},i.prototype.decodeCulShift=function(t){o(this,this.stream),this.help=this.range>>>t;var e=this.low/this.help>>>0;return e>>>t?(1<<t)-1:e},i.prototype.decodeUpdate=function(t,e,r){var i=this.help*e;this.low-=i,e+t<r?this.range=this.help*t:this.range-=i},i.prototype.decodeBit=function(){var t=this.decodeCulShift(1);return this.decodeUpdate(1,t,2),t},i.prototype.decodeByte=function(){var t=this.decodeCulShift(8);return this.decodeUpdate(1,t,256),t},i.prototype.decodeShort=function(){var t=this.decodeCulShift(16);return this.decodeUpdate(1,t,65536),t},i.prototype.decodeFinish=function(){o(this,this.stream)},i.prototype.writeBit=i.prototype.encodeBit,i.prototype.readBit=i.prototype.decodeBit,i.prototype.writeByte=i.prototype.encodeByte,i.prototype.readByte=i.prototype.decodeByte,i}(),o=function(){var t=function(){};return t.prototype.readByte=function(){var t=[0];return 0===this.read(t,0,1)?(this._eof=!0,-1):t[0]},t.prototype.read=function(t,e,r){for(var i,s=0;s<r;){if(-1===(i=this.readByte())){this._eof=!0;break}t[e+s++]=i}return s},t.prototype.eof=function(){return!!this._eof},t.prototype.seek=function(t){throw new Error("Stream is not seekable.")},t.prototype.tell=function(){throw new Error("Stream is not seekable.")},t.prototype.writeByte=function(t){var e=[t];this.write(e,0,1)},t.prototype.write=function(t,e,r){var i;for(i=0;i<r;i++)this.writeByte(t[e+i]);return r},t.prototype.flush=function(){},t.EOF=-1,t}(),n=function(){var t=function(t){(function(){var e=256;this.readBit=function(){if(0==(255&e)){var r=t.readByte();if(r===o.EOF)return this._eof=!0,r;e=r<<1|1}var i=256&e?1:0;return e<<=1,i},this.seekBit=function(t){var e=t>>>3,r=t-8*e;this.seek(e),this._eof=!1,this.readBits(r)},this.tellBit=function(){for(var r=8*t.tell(),i=e;0!=(255&i);)r--,i<<=1;return r},this.readByte=function(){return 0==(255&e)?t.readByte():this.readBits(8)},this.seek=function(r){t.seek(r),e=256}}).call(this),function(){var e=1;this.writeBit=function(r){e<<=1,r&&(e|=1),256&e&&(t.writeByte(255&e),e=1)},this.writeByte=function(r){1===e?t.writeByte(r):t.writeBits(8,r)},this.flush=function(){for(;1!==e;)this.writeBit(0);t.flush&&t.flush()}}.call(this)};return t.EOF=o.EOF,(t.prototype=Object.create(o.prototype)).readBits=function(t){var e,r=0;if(t>31)return(r=65536*this.readBits(t-16))+this.readBits(16);for(e=0;e<t;e++)r<<=1,this.readBit()>0&&r++;return r},t.prototype.writeBits=function(t,e){if(t>32){var r=65535&e,i=(e-r)/65536;return this.writeBits(t-16,i),void this.writeBits(16,r)}var s;for(s=t-1;s>=0;s--)this.writeBit(e>>>s&1)},t}(),h=function(){var t=Object.create(null),e=o.EOF;t.coerceInputStream=function(t,r){if("readByte"in t){if(r&&!("read"in t)){var i=t;(t=new o).readByte=function(){var t=i.readByte();return t===e&&(this._eof=!0),t},"size"in i&&(t.size=i.size),"seek"in i&&(t.seek=function(t){i.seek(t),this._eof=!1}),"tell"in i&&(t.tell=i.tell.bind(i))}}else{var s=t;(t=new o).size=s.length,t.pos=0,t.readByte=function(){return this.pos>=this.size?e:s[this.pos++]},t.read=function(t,e,r){for(var i=0;i<r&&this.pos<s.length;)t[e++]=s[this.pos++],i++;return i},t.seek=function(t){this.pos=t},t.tell=function(){return this.pos},t.eof=function(){return this.pos>=s.length}}return t};var r=function(t,e){this.buffer=t,this.resizeOk=e,this.pos=0};(r.prototype=Object.create(o.prototype)).writeByte=function(e){if(this.resizeOk&&this.pos>=this.buffer.length){var r=t.makeU8Buffer(2*this.buffer.length);r.set(this.buffer),this.buffer=r}this.buffer[this.pos++]=e},r.prototype.getBuffer=function(){if(this.pos!==this.buffer.length){if(!this.resizeOk)throw new TypeError("outputsize does not match decoded input");var e=t.makeU8Buffer(this.pos);e.set(this.buffer.subarray(0,this.pos)),this.buffer=e}return this.buffer},t.coerceOutputStream=function(e,i){var s={stream:e,retval:e};if(e){if("object"==typeof e&&"writeByte"in e)return s;s.stream=new r("number"==typeof i?t.makeU8Buffer(i):e,!1)}else s.stream=new r(t.makeU8Buffer(16384),!0);return Object.defineProperty(s,"retval",{get:s.stream.getBuffer.bind(s.stream)}),s},t.compressFileHelper=function(e,r,i){return function(s,o,n){s=t.coerceInputStream(s);var h,a,u=t.coerceOutputStream(o,o);for(o=u.stream,h=0;h<e.length;h++)o.writeByte(e.charCodeAt(h));if(a="size"in s&&s.size>=0?s.size:-1,i){var f=t.coerceOutputStream([]);for(t.writeUnsignedNumber(f.stream,a+1),f=f.retval,h=0;h<f.length-1;h++)o.writeByte(f[h]);i=f[f.length-1]}else t.writeUnsignedNumber(o,a+1);return r(s,o,a,n,i),u.retval}},t.decompressFileHelper=function(e,r){return function(i,s){var o;for(i=t.coerceInputStream(i),o=0;o<e.length;o++)if(e.charCodeAt(o)!==i.readByte())throw new Error("Bad magic");var n=t.readUnsignedNumber(i)-1,h=t.coerceOutputStream(s,n);return s=h.stream,r(i,s,n),h.retval}},t.compressWithModel=function(t,r,i){for(var s=0;s!==r;){var o=t.readByte();if(o===e){i.encode(256);break}i.encode(o),s++}},t.decompressWithModel=function(t,e,r){for(var i=0;i!==e;){var s=r.decode();if(256===s)break;t.writeByte(s),i++}},t.writeUnsignedNumber=function(t,e){var r,i=[];do{i.push(127&e),e=Math.floor(e/128)}while(0!==e);for(i[0]|=128,r=i.length-1;r>=0;r--)t.writeByte(i[r]);return t},t.readUnsignedNumber=function(t){for(var e,r=0;;){if(128&(e=t.readByte())){r+=127&e;break}r=128*(r+e)}return r};var i=function(t){for(var e=0,r=t.length;e<r;e++)t[e]=0;return t},s=function(t){return i(new Array(t))},n=function(t){return t};"undefined"!=typeof process&&Array.prototype.some.call(new Uint32Array(128),(function(t){return 0!==t}))&&(n=i),t.makeU8Buffer="undefined"!=typeof Uint8Array?function(t){return n(new Uint8Array(t))}:"undefined"!=typeof Buffer?function(t){var e=new Buffer(t);return e.fill(0),e}:s,t.makeU16Buffer="undefined"!=typeof Uint16Array?function(t){return n(new Uint16Array(t))}:s,t.makeU32Buffer="undefined"!=typeof Uint32Array?function(t){return n(new Uint32Array(t))}:s,t.makeS32Buffer="undefined"!=typeof Int32Array?function(t){return n(new Int32Array(t))}:s,t.arraycopy=function(t,e){for(var r=0,i=e.length;r<i;r++)t[r]=e[r];return t};var h=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],a=t.fls=function(t){return t>4294967295?32+a(Math.floor(t/4294967296)):0!=(4294901760&t)?0!=(4278190080&t)?24+h[t>>>24&255]:16+h[t>>>16]:0!=(65280&t)?8+h[t>>>8]:h[t]};return t.log2c=function(t){return 0===t?-1:a(t-1)},t}(),a=function(){var t=function(t,e,r,i){var s,o=h.fls(t-1);for(this.extraStates=+e||0,this.lgDistanceModel=r(1+o+e),this.distanceModel=[],s=2;s<=o;s++){var n=s-1;this.distanceModel[s]=i(1<<n)}};return t.prototype.encode=function(t){if(t<2)this.lgDistanceModel.encode(t+this.extraStates);else{var e=h.fls(t);this.lgDistanceModel.encode(e+this.extraStates);var r=t&(1<<e-1)-1;this.distanceModel[e].encode(r)}},t.prototype.decode=function(){var t=this.lgDistanceModel.decode()-this.extraStates;return t<2?t:(1<<t-1)+this.distanceModel[t].decode()},t}(),u=function(){var t=function(t,e,r,i){this.up=t,this.down=e,this.symbol=r,this.weight=i};t.prototype.clone=function(){return new t(this.up,this.down,this.symbol,this.weight)},t.prototype.set=function(t){this.up=t.up,this.down=t.down,this.symbol=t.symbol,this.weight=t.weight};var e=function(e,r,i,s){var o;for((!r||r>e)&&(r=e),(r<<=1)&&r--,this.table=[],o=0;o<=r;o++)this.table[o]=new t(0,0,0,0);if(this.map=[],this.size=e)for(o=0;o<e;o++)this.map[o]=0;this.esc=this.root=r,i&&(this.readBit=i.readBit.bind(i),this.writeBit=i.writeBit.bind(i)),this.max_weight=s};return e.factory=function(t,r){return function(i){return new e(i,i,t,r)}},e.prototype.split=function(t){var e,r;return(e=this.esc)?(this.esc--,(r=this.esc)?(this.table[e].down=r,this.table[e].weight=1,this.table[r].up=e,this.esc--):(e=0,r=1),this.table[r].symbol=t,this.table[r].weight=0,this.table[r].down=0,this.map[t]=r,this.table[this.esc].weight=0,this.table[this.esc].down=0,this.table[this.esc].up=e,r):0},e.prototype.leader=function(t){for(var e,r,i=this.table[t].weight,s=t;i===this.table[s+1].weight;)s++;return s===t?t:(r=this.table[t].symbol,e=this.table[s].symbol,this.table[s].symbol=r,this.table[t].symbol=e,this.map[r]=s,this.map[e]=t,s)},e.prototype.slide=function(t){var e,r=t;if(1&(e=this.table[r++].clone()).weight)for(;e.weight>this.table[r+1].weight;)r++;return this.table[t].set(this.table[r]),this.table[r].set(e),this.table[r].up=this.table[t].up,this.table[t].up=e.up,1&e.weight?(this.table[e.down].up=r,this.table[e.down-1].up=r,this.map[this.table[t].symbol]=t):(this.table[this.table[t].down-1].up=t,this.table[this.table[t].down].up=t,this.map[e.symbol]=r),r},e.prototype.increment=function(t){var e;for(this.table[t].up===t+1?(this.table[t].weight+=2,t++):t=this.leader(t);this.table[t].weight+=2,e=this.table[t].up;){for(;this.table[t].weight>this.table[t+1].weight;)t=this.slide(t);t=1&this.table[t].weight?e:this.table[t].up}this.max_weight&&this.table[this.root].weight>=this.max_weight&&this.scale(1)},e.prototype.scale=function(t){for(var e,r,i=this.esc;++i<=this.root;)for(1&this.table[i].weight?(e=-2&this.table[this.table[i].down].weight)&&(e+=1|this.table[this.table[i].down-1].weight):(e=this.table[i].weight>>t&-2)||(this.map[this.table[i].symbol]=0,this.esc++&&this.esc++),this.table[i].weight=e,r=i;e<this.table[--r].weight;)this.slide(r);this.table[this.esc].down=0},e.prototype.sendid=function(t){for(var e,r=0;t--;)this.map[t]||r++;if(e=this.size-Math.floor((this.root-this.esc)/2)-1)do{this.writeBit(1&r),r>>=1}while(e>>=1)},e.prototype.encode=function(t){var e,r,i,s,o=1;if(t<this.size&&((i=s=this.map[t])||(i=this.esc))){for(;r=this.table[i].up;)o<<=1,o|=1&i,i=r;for(;e=1&o,o>>=1;)this.writeBit(e);s||(this.sendid(t),s=this.split(t)),this.increment(s)}},e.prototype.readid=function(){var t,e,r=0,i=1;if(t=this.size-Math.floor((this.root-this.esc)/2)-1)do{r|=this.readBit()?i:0,i<<=1}while(t>>=1);for(e=0;e<this.size;e++)if(!this.map[e]&&!r--)return e;return 0},e.prototype.decode=function(){for(var t,e,r=this.root;e=this.table[r].down;)r=this.readBit()?e-1:e;if(r===this.esc){if(!this.esc)return 0;t=this.readid(),r=this.split(t)}else t=this.table[r].symbol;return this.increment(r),t},e.MAGIC="huff",e.compressFile=h.compressFileHelper(e.MAGIC,(function(t,r,i,s){var o=new n(r),a=256;i<0&&a++;var u=new e(257,a,o,8191);h.compressWithModel(t,i,u),o.flush()})),e.decompressFile=h.decompressFileHelper(e.MAGIC,(function(t,r,i){var s=new n(t),o=256;i<0&&o++;var a=new e(257,o,s,8191);h.decompressWithModel(r,i,a)})),e}(),f=function(){var t=function(t,e){this.bitstream=t,this.bits=h.fls(e-1)};return t.factory=function(e){return function(r){return new t(e,r)}},t.prototype.encode=function(t){var e;for(e=this.bits-1;e>=0;e--){var r=t>>>e&1;this.bitstream.writeBit(r)}},t.prototype.decode=function(){var t,e=0;for(t=this.bits-1;t>=0;t--)e<<=1,this.bitstream.readBit()&&e++;return e},t.MAGIC="nomo",t.compressFile=h.compressFileHelper(t.MAGIC,(function(e,r,i,s){var o=new n(r),a=new t(o,i<0?257:256);h.compressWithModel(e,i,a),o.flush()})),t.decompressFile=h.decompressFileHelper(t.MAGIC,(function(e,r,i){var s=new n(e),o=new t(s,i<0?257:256);h.decompressWithModel(r,i,o)})),t}(),c=function(){var t=65535,e=4294901760,r=16,i=4294901758,o=function(t,e,i,s){var o;for(this.coder=t,this.numSyms=e+1,this.tree=h.makeU32Buffer(2*this.numSyms),this.increment=+s||256,this.max_prob=+i||65280,o=0;o<e;o++)this.tree[this.numSyms+o]=1;this.tree[this.numSyms+o]=0|this.increment<<r,this._sumTree()};return o.factory=function(t,e,r){return function(i){return new o(t,i,e,r)}},o.prototype.clone=function(){var t,e=new o(this.coder,this.size,this.max_prob,this.increment);for(t=1;t<this.tree.length;t++)e.tree[t]=this.tree[t];return e},o.prototype.encode=function(i){var s=this.numSyms+i,o=this.tree[s],n=e,h=r,a=this.increment<<r;0==(o&e)?(this.encode(this.numSyms-1),n=t,a-=1,h=0):i===this.numSyms-1&&(this.tree[1]&t)>>>0==1&&(a=-this.tree[s]);for(var u=0;s>1;){var f=s>>>1;1&s&&(u+=this.tree[2*f]),this.tree[s]+=a,s=f}var c=this.tree[1];this.tree[1]+=a,o=(o&n)>>>h,u=(u&n)>>>h,c=(c&n)>>>h,this.coder.encodeFreq(o,u,c),(this.tree[1]&e)>>>r>=this.max_prob&&this._rescale()},o.prototype._decode=function(i){var s=e,o=r,n=this.increment<<r;i&&(s=t,n-=1,o=0);for(var h=(this.tree[1]&s)>>>o,a=this.coder.decodeCulFreq(h),u=1,f=0;u<this.numSyms;){this.tree[u]+=n;var c=(this.tree[2*u]&s)>>>o;u*=2,a-f>=c&&(f+=c,u++)}var p=u-this.numSyms,d=(this.tree[u]&s)>>>o;if(this.tree[u]+=n,this.coder.decodeUpdate(d,f,h),p===this.numSyms-1&&(this.tree[1]&t)>>>0==1)for(n=-this.tree[u];u>=1;)this.tree[u]+=n,u>>>=1;return(this.tree[1]&e)>>>r>=this.max_prob&&this._rescale(),p},o.prototype.decode=function(){var t=this._decode(!1);return t===this.numSyms-1&&(t=this._decode(!0)),t},o.prototype._rescale=function(){var e,r,s=!0;for(e=0;e<this.numSyms-1;e++)0==((r=this.tree[this.numSyms+e])&t)?(0===(r=(r&i)>>>1)&&(r=1,s=!1),this.tree[this.numSyms+e]=r):s=!1;r=((r=this.tree[this.numSyms+e])&i)>>>1,s?r=0:0===r&&(r=65536),this.tree[this.numSyms+e]=r,this._sumTree()},o.prototype._sumTree=function(){var t;for(t=this.numSyms-1;t>0;t--)this.tree[t]=this.tree[2*t]+this.tree[2*t+1]},o.MAGIC="fenw",o.compressFile=h.compressFileHelper(o.MAGIC,(function(t,e,r,i,n){var a=new s(e);a.encodeStart(n,1);var u=new o(a,r<0?257:256);h.compressWithModel(t,r,u),a.encodeFinish()}),!0),o.decompressFile=h.decompressFileHelper(o.MAGIC,(function(t,e,r){var i=new s(t);i.decodeStart(!0);var n=new o(i,r<0?257:256);h.decompressWithModel(e,r,n),i.decodeFinish()})),o}(),function(){var t=256,e=function(e,r,i){var s,o=this.numSyms=r;for(this.coder=e,this.prob=h.makeU16Buffer(r+2),this.escape=h.makeU16Buffer(r+1),this.update=h.makeU16Buffer(r+1),this.prob[o+1]=t,s=0;s<=this.numSyms;s++)this.escape[s]=s;if(this.updateCount=0,this.updateThresh=t-Math.floor(128),i){for(this.probToSym=h.makeU16Buffer(t),this.escProbToSym=h.makeU16Buffer(this.numSyms),s=0;s<t;s++)this.probToSym[s]=o;for(s=0;s<this.numSyms;s++)this.escProbToSym[s]=s}};e.factory=function(t,r){return function(i){return new e(t,i,r)}},e.prototype._update=function(e,r){if(e===this.numSyms){if(this.update[e]>=40)return;if(this.updateCount>=this.updateThresh-1)return}if(this.update[e]++,this.updateCount++,!(this.updateCount<this.updateThresh)){var i,s,o,n,h,a;for(this.escape[0]=this.prob[0]=i=s=o=0,n=0;n<this.numSyms+1;n++){var u=(this.prob[n+1]-this.prob[n]>>>1)+this.update[n];u?(this.prob[n]=i,i+=u,1&u&&o++,this.escape[n]=s):(this.prob[n]=i,this.escape[n]=s,s++)}for(this.prob[n]=i,this.updateThresh=t-Math.floor((i-o)/2),n=0;n<this.numSyms+1;n++)this.update[n]=0;if(this.update[this.numSyms]=1,this.updateCount=1,r)for(n=0,h=0,a=0;n<this.numSyms+1;n++){for(var f=this.prob[n+1];h<f;h++)this.probToSym[h]=n;for(var c=this.escape[n+1];a<c;a++)this.escProbToSym[a]=n}}},e.prototype.encode=function(t){var e=this.prob[t],r=this.prob[t+1]-e;if(r)return this.coder.encodeShift(r,e,8),this._update(t);this.encode(this.numSyms),e=this.escape[t],r=this.escape[t+1]-e;var i=this.escape[this.numSyms];return this.coder.encodeFreq(r,e,i),this._update(t)},e.prototype.decode=function(){var e=this.coder.decodeCulShift(8),r=this.probToSym[e],i=this.prob[r],s=this.prob[r+1]-i;if(this.coder.decodeUpdate(s,i,t),this._update(r,!0),r!==this.numSyms)return r;var o=this.escape[this.numSyms];return e=this.coder.decodeCulFreq(o),r=this.escProbToSym[e],i=this.escape[r],s=this.escape[r+1]-i,this.coder.decodeUpdate(s,i,o),this._update(r,!0),r},e.MAGIC="dfsm",e.compressFile=h.compressFileHelper(e.MAGIC,(function(t,r,i,o,n){var a=new s(r);a.encodeStart(n,1);var u=new e(a,i<0?257:256);h.compressWithModel(t,i,u),a.encodeFinish()}),!0),e.decompressFile=h.decompressFileHelper(e.MAGIC,(function(t,r,i){var o=new s(t);o.decodeStart(!0);var n=new e(o,i<0?257:256,!0);h.decompressWithModel(r,i,n),o.decodeFinish()}))}(),p=function(){var t=function(t,e,r){var i;for(this.literalModel=[],i=0;i<e;i++)this.literalModel[i]=t(r)};return t.prototype.encode=function(t,e){this.literalModel[e].encode(t)},t.prototype.decode=function(t){return this.literalModel[t].decode()},t.MAGIC="ctx1",t.compressFile=h.compressFileHelper(t.MAGIC,(function(e,r,i,s){var o=new n(r),a=256;i<0&&a++;var f=u.factory(o,8191),c=new t(f,256,a),p=32,d={encode:function(t){c.encode(t,p),p=t}};h.compressWithModel(e,i,d),o.flush()})),t.decompressFile=h.decompressFileHelper(t.MAGIC,(function(e,r,i){var s=new n(e),o=256;i<0&&o++;var a=u.factory(s,8191),f=new t(a,256,o),c=32,p={decode:function(){var t=f.decode(c);return c=t,t}};h.decompressWithModel(r,i,p)})),t}(),d=function(){var t=Object.create(null);t.MAGIC="lzp3";var e=1<<20,r=1048575,i=65535,d=function(t){this.buffer=h.makeU8Buffer(Math.min(t+4,e)),this.pos=0,this.ctxt4=h.makeU32Buffer(65536),this.ctxt3=h.makeU32Buffer(4096),this.ctxt2=h.makeU32Buffer(65536),this.put(99),this.put(83),this.put(97),this.put(32)};return d.prototype.put=function(t){return this.buffer[this.pos++]=t,this.pos>=e&&(this.pos=0),t},d.prototype.get=function(t){return this.buffer[1048575&t]},d.prototype.context=function(t,r){var i,s=0;for(t=t-r&1048575,i=0;i<r;i++)s=s<<8|this.buffer[t++],t>=e&&(t=0);return s},d.prototype.getIndex=function(t,e){var r=this.context(t,4),s=65535&(r>>>15^r),o=4095&(r>>>11^r),n=r&i,h=0;return 0===e&&(0!==(h=this.ctxt4[s])&&r!==this.context(h-1,4)&&(h=0),0===h&&(0!==(h=this.ctxt3[o])&&(16777215&r)!==this.context(h-1,3)&&(h=0),0===h&&0!==(h=this.ctxt2[n])&&(r&&i)!==this.context(h-1,2)&&(h=0))),e&&e--,this.ctxt4[s]=this.ctxt3[o]=this.ctxt2[n]=1+(t|e<<20),h},t.compressFile=h.compressFileHelper(t.MAGIC,(function(t,i,n,h){var u,l,y,m=new d(n>=0?n:e),w=new s(i);w.encodeStart(0,0),u=c.factory(w,65280,256);var b=f.factory(w);l=function(t){return t>256?b(t):u(t)},y=function(){w.encodeFinish()};var v,B=new p(u,256,n<0?257:256),g=[];for(v=0;v<16;v++)g[v]=new a(1048576,1,u,l);for(var S,M=0,F=0;M!==n;){var k=t.readByte();S=m.pos;var U=m.getIndex(S,0);if(0!==U){for(var C=1+(--U>>>20),A=0;m.get(U+A)===k&&A<r;)A++,m.put(k),k=t.readByte();C===A?g[15&F].encode(-1):g[15&F].encode(A),m.getIndex(S,A),M+=A,F<<=1,A>0&&(F|=1)}var x=m.get(m.pos-1);if(k===o.EOF){n<0&&B.encode(256,x);break}B.encode(k,x),m.put(k),M++}y&&y()})),t.decompressFile=h.decompressFileHelper(t.MAGIC,(function(t,r,o){var h,l,y,m=!!(128&t.readByte()),w=new d(o>=0?o:e);if(m){var b=new n(t);h=u.factory(b,i),l=f.factory(b)}else{var v=new s(t);v.decodeStart(!0),h=c.factory(v,65280,256);var B=f.factory(v);l=function(t){return t>256?B(t):h(t)},y=function(){v.decodeFinish()}}var g,S=new p(h,256,o<0?257:256),M=[];for(g=0;g<16;g++)M[g]=new a(1048576,1,h,l);for(var F,k,U=0,C=0;U!==o;){F=w.pos;var A=w.getIndex(F,0);if(0!==A){var x=1+(--A>>>20),_=M[15&C].decode();for(_<0&&(_=x),g=0;g<_;g++)k=w.get(A+g),r.writeByte(w.put(k));w.getIndex(F,_),U+=_,C<<=1,_>0&&(C|=1)}if(U===o)break;var I=w.get(w.pos-1);if(256===(k=S.decode(I)))break;r.writeByte(w.put(k)),U++}y&&y()})),t}(),"COMPRESS_OBJECT"===e?r(Uint8Array.from(d.compressFile(new TextEncoder("utf-8").encode(JSON.stringify(t,null,0))))):"DECOMPRESS_UINT8A"===e?r(JSON.parse((new TextDecoder).decode(Uint8Array.from(d.decompressFile(t))))):i(null)}))};`
    + "return fu;"
)();

/*
    var fu = async function(uint8a_or_obj, mode) {return new Promise(function(resolve, reject){
        
        "use strict";
        var RangeCoder          //no dependencies
            ,Stream              //no dependencies
            ,BitStream           //depands on [Stream]
            ,Util                //depands on [Stream]
            ,LogDistanceModel    //depands on [Util(Stream)]
            ,Huffman             //depands on [Util(Stream),BitStream(Stream)]
            ,NoModel             //depands on [Util(Stream),BitStream(Stream)]
            ,FenwickModel        //depands on [RangeCoder, Stream, Util(Stream)]
            ,DefSumModel         //depands on [RangeCoder, Stream, Util(Stream)]
            ,Context1Model       //depands on [Util(Stream),BitStream(Stream),Huffman(Util(Stream),BitStream(Stream))]
            ,Lzp3                //depands on [RangeCoder, Stream, Util(Stream), LogDistanceModel(Util(Stream)), NoModel(Util(Stream),BitStream(Stream)), FenwickModel(RangeCoder, Stream, Util(Stream)), Context1Model(Util(Stream),BitStream(Stream),Huffman(Util(Stream),BitStream(Stream)))]
        ;
        
        
        RangeCoder = (function(){
            /* Range Coder.  Inspired by rangecod.c from rngcod13.zip from
             *    http://www.compressconsult.com/rangecoder/
             * This JavaScript version is:
             *    Copyright (c) 2013 C. Scott Ananian.
             $/
        // Uses 32-bit integer math.  Hopefully the JavaScript runtime figures
        // that out. ;)
        // see https://github.com/kripken/emscripten/wiki/LLVM-Types-in-JavaScript
        // for some hints on doing 32-bit unsigned match in JavaScript.
        // One key is the use of ">>>0" to change a signed result to unsigned.
            var CODE_BITS = 32;
            var Top_value = Math.pow(2, CODE_BITS - 1);
            var SHIFT_BITS = (CODE_BITS - 9);
            var EXTRA_BITS = ((CODE_BITS - 2) % 8 + 1);
            var Bottom_value = (Top_value >>> 8);

            var MAX_INT = Math.pow(2, CODE_BITS) - 1;

            /* it is highly recommended that the total frequency count is less  $/
            /* than 1 << 19 to minimize rounding effects.                       $/
            /* the total frequency count MUST be less than 1<<23                $/


            var RangeCoder = function(stream) {
                this.low = 0; /* low end of interval $/
                this.range = Top_value; /* length of interval $/
                this.buffer = 0; /* buffer for input/output $/
                this.help = 0; /* bytes_to_follow / intermediate value $/
                this.bytecount = 0; /* counter for output bytes $/
                this.stream = stream;
            };

            /* Do the normalization before we need a defined state, instead of
             * after messing it up.  This simplifies starting and ending. $/
            var enc_normalize = function(rc, outputStream) {
                while (rc.range <= Bottom_value) { /* do we need renormalization? $/
                    if (rc.low < (0xFF << SHIFT_BITS)) { //no carry possible, so output
                        outputStream.writeByte(rc.buffer);
                        for (; rc.help; rc.help--)
                            outputStream.writeByte(0xFF);
                        rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;
                    } else if (rc.low & Top_value) { /* carry now, no future carry $/
                        outputStream.writeByte(rc.buffer + 1);
                        for (; rc.help; rc.help--)
                            outputStream.writeByte(0x00);
                        rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;
                    } else {
                        rc.help++;
                        if (rc.help > MAX_INT)
                            throw new Error("Too many bytes outstanding, " +
                                "file too large!");
                    }
                    rc.range = (rc.range << 8) >>> 0; /*ensure result remains positive$/
                    rc.low = ((rc.low << 8) & (Top_value - 1)) >>> 0; /* unsigned $/
                    rc.bytecount++;
                }
            };

            /* Start the encoder                                         $/
            /* c is written as the first byte in the datastream.
             * one could do w/o, but then you have an additional if per output byte $/
            RangeCoder.prototype.encodeStart = function(c, initlength) {
                this.low = 0;
                this.range = Top_value;
                this.buffer = c;
                this.help = 0;
                this.bytecount = initlength;
            };

            /* Encode a symbol using frequencies                         $/
            /* rc is the range coder to be used                          $/
            /* sy_f is the interval length (frequency of the symbol)     $/
            /* lt_f is the lower end (frequency sum of < symbols)        $/
            /* tot_f is the total interval length (total frequency sum)  $/
            /* or (faster): tot_f = (code_value)1<<shift                             $/
            RangeCoder.prototype.encodeFreq = function(sy_f, lt_f, tot_f) {
                enc_normalize(this, this.stream);
                var r = (this.range / tot_f) >>> 0; // note coercion to integer
                var tmp = r * lt_f;
                this.low += tmp;
                if ((lt_f + sy_f) < tot_f) {
                    this.range = r * sy_f;
                } else {
                    this.range -= tmp;
                }
            };
            RangeCoder.prototype.encodeShift = function(sy_f, lt_f, shift) {
                enc_normalize(this, this.stream);
                var r = this.range >>> shift;
                var tmp = r * lt_f;
                this.low += tmp;
                if ((lt_f + sy_f) >>> shift) {
                    this.range -= tmp;
                } else {
                    this.range = r * sy_f;
                }
            };
            /* Encode a bit w/o modelling. $/
            RangeCoder.prototype.encodeBit = function(b) {
                this.encodeShift(1, b ? 1 : 0, 1);
            };
            /* Encode a byte w/o modelling. $/
            RangeCoder.prototype.encodeByte = function(b) {
                this.encodeShift(1, b, 8);
            };
            /* Encode a short w/o modelling. $/
            RangeCoder.prototype.encodeShort = function(s) {
                this.encodeShift(1, s, 16);
            };

            /* Finish encoding                                           $/
            /* returns number of bytes written                           $/
            RangeCoder.prototype.encodeFinish = function() {
                var outputStream = this.stream;
                enc_normalize(this, outputStream);
                this.bytecount += 5;
                var tmp = this.low >>> SHIFT_BITS;
                if ((this.low & (Bottom_value - 1)) >= ((this.bytecount & 0xFFFFFF) >>> 1)) {
                    tmp++;
                }
                if (tmp > 0xFF) { /* we have a carry $/
                    outputStream.writeByte(this.buffer + 1);
                    for (; this.help; this.help--)
                        outputStream.writeByte(0x00);
                } else { /* no carry $/
                    outputStream.writeByte(this.buffer);
                    for (; this.help; this.help--)
                        outputStream.writeByte(0xFF);
                }
                outputStream.writeByte(tmp & 0xFF);
                // XXX: i'm pretty sure these could be three arbitrary bytes
                //      they are consumed by the decoder at the end
                outputStream.writeByte((this.bytecount >>> 16) & 0xFF);
                outputStream.writeByte((this.bytecount >>> 8) & 0xFF);
                outputStream.writeByte((this.bytecount) & 0xFF);
                return this.bytecount;
            };

            /* Start the decoder; you need to provide the *second* byte from the
             * datastream. (The first byte was provided to startEncoding and is
             * ignored by the decoder.)
             $/
            RangeCoder.prototype.decodeStart = function(skipInitialRead) {
                var c = skipInitialRead ? 0 : this.stream.readByte();
                if (typeof(c) !== 'number' || c < 0) {
                    return c; // EOF
                }
                this.buffer = this.stream.readByte();
                this.low = this.buffer >>> (8 - EXTRA_BITS);
                this.range = 1 << EXTRA_BITS;
                return c;
            };

            var dec_normalize = function(rc, inputStream) {
                while (rc.range <= Bottom_value) {
                    rc.low = (rc.low << 8) | ((rc.buffer << EXTRA_BITS) & 0xFF);
                    /* rc.low could be negative here; don't fix it quite yet $/
                    rc.buffer = inputStream.readByte();
                    rc.low |= rc.buffer >>> (8 - EXTRA_BITS);
                    rc.low = rc.low >>> 0; /* fix it now $/
                    rc.range = (rc.range << 8) >>> 0; /* ensure stays positive $/
                }
            };

            /* Calculate cumulative frequency for next symbol. Does NO update!$/
            /* rc is the range coder to be used                          $/
            /* tot_f is the total frequency                              $/
            /* or: totf is (code_value)1<<shift                                      $/
            /* returns the <= cumulative frequency                         $/
            RangeCoder.prototype.decodeCulFreq = function(tot_f) {
                dec_normalize(this, this.stream);
                this.help = (this.range / tot_f) >>> 0; // note coercion to integer
                var tmp = (this.low / this.help) >>> 0; // again
                return (tmp >= tot_f ? tot_f - 1 : tmp);
            };
            RangeCoder.prototype.decodeCulShift = function(shift) {
                dec_normalize(this, this.stream);
                this.help = this.range >>> shift;
                var tmp = (this.low / this.help) >>> 0; // coercion to unsigned
                // shift is less than 31, so shift below will remain positive
                return ((tmp >>> shift) ? (1 << shift) - 1 : tmp);
            };

            /* Update decoding state                                     $/
            /* rc is the range coder to be used                          $/
            /* sy_f is the interval length (frequency of the symbol)     $/
            /* lt_f is the lower end (frequency sum of < symbols)        $/
            /* tot_f is the total interval length (total frequency sum)  $/
            RangeCoder.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {
                var tmp = this.help * lt_f; // should not overflow!
                this.low -= tmp;
                if (lt_f + sy_f < tot_f) {
                    this.range = (this.help * sy_f);
                } else {
                    this.range -= tmp;
                }
            };

            /* Decode a bit w/o modelling. $/
            RangeCoder.prototype.decodeBit = function() {
                var tmp = this.decodeCulShift(1);
                this.decodeUpdate(1, tmp, 1 << 1);
                return tmp;
            };
            /* decode a byte w/o modelling $/
            RangeCoder.prototype.decodeByte = function() {
                var tmp = this.decodeCulShift(8);
                this.decodeUpdate(1, tmp, 1 << 8);
                return tmp;
            };
            /* decode a short w/o modelling $/
            RangeCoder.prototype.decodeShort = function() {
                var tmp = this.decodeCulShift(16);
                this.decodeUpdate(1, tmp, 1 << 16);
                return tmp;
            };

            /* Finish decoding $/
            RangeCoder.prototype.decodeFinish = function() {
                /* normalize to use up all bytes $/
                dec_normalize(this, this.stream);
            };

            /** Utility functions $/

        // bitstream interface
            RangeCoder.prototype.writeBit = RangeCoder.prototype.encodeBit;
            RangeCoder.prototype.readBit = RangeCoder.prototype.decodeBit;

        // stream interface
            RangeCoder.prototype.writeByte = RangeCoder.prototype.encodeByte;
            RangeCoder.prototype.readByte = RangeCoder.prototype.decodeByte;

            return RangeCoder;

        }());


        Stream = (function(){
            /** Abstract Stream interface, for byte-oriented i/o. $/
            var EOF = -1;

            var Stream = function() {
                /* ABSTRACT $/
            };
        // you must define one of read / readByte for a readable stream
            Stream.prototype.readByte = function() {
                var buf = [0];
                var len = this.read(buf, 0, 1);
                if (len === 0) { this._eof = true; return EOF; }
                return buf[0];
            };
            Stream.prototype.read = function(buf, bufOffset, length) {
                var ch, bytesRead = 0;
                while (bytesRead < length) {
                    ch = this.readByte();
                    if (ch === EOF) { this._eof = true; break; }
                    buf[bufOffset + (bytesRead++)] = ch;
                }
                return bytesRead;
            };
            Stream.prototype.eof = function() { return !!this._eof; };    // reasonable default implementation of 'eof'
            Stream.prototype.seek = function(pos) {                       // not all readable streams are seekable
                throw new Error('Stream is not seekable.');
            };
            Stream.prototype.tell = function() {
                throw new Error('Stream is not seekable.');
            };
            Stream.prototype.writeByte = function(_byte) {    // you must define one of write / writeByte for a writable stream
                var buf = [_byte];
                this.write(buf, 0, 1);
            };
            Stream.prototype.write = function(buf, bufOffset, length) {
                var i;
                for (i = 0; i < length; i++) {
                    this.writeByte(buf[bufOffset + i]);
                }
                return length;
            };
            Stream.prototype.flush = function(){};      //flush will happily do nothing if you don't override it.
            Stream.EOF = EOF;                           //export EOF as a constant.

            return Stream;
        }());


        BitStream = (function(){
            /** Big-Endian Bit Stream, implemented on top of a (normal byte) stream. $/
            var BitStream = function(stream) {
                (function() {
                    var bufferByte = 0x100; // private var for readers
                    this.readBit = function() {
                        if ((bufferByte & 0xFF) === 0) {
                            var ch = stream.readByte();
                            if (ch === Stream.EOF) {
                                this._eof = true;
                                return ch; /* !!! $/
                            }
                            bufferByte = (ch << 1) | 1;
                        }
                        var bit = (bufferByte & 0x100) ? 1 : 0;
                        bufferByte <<= 1;
                        return bit;
                    };
                    // seekable iff the provided stream is
                    this.seekBit = function(pos) {
                        var n_byte = pos >>> 3;
                        var n_bit = pos - (n_byte * 8);
                        this.seek(n_byte);
                        this._eof = false;
                        this.readBits(n_bit);
                    };
                    this.tellBit = function() {
                        var pos = stream.tell() * 8;
                        var b = bufferByte;
                        while ((b & 0xFF) !== 0) {
                            pos--;
                            b <<= 1;
                        }
                        return pos;
                    };
                    // implement byte stream interface as well.
                    this.readByte = function() {
                        if ((bufferByte & 0xFF) === 0) {
                            return stream.readByte();
                        }
                        return this.readBits(8);
                    };
                    this.seek = function(pos) {
                        stream.seek(pos);
                        bufferByte = 0x100;
                    };
                })
                    .call(this);
                (function() {
                    var bufferByte = 1; // private var for writers
                    this.writeBit = function(b) {
                        bufferByte <<= 1;
                        if (b) { bufferByte |= 1; }
                        if (bufferByte & 0x100) {
                            stream.writeByte(bufferByte & 0xFF);
                            bufferByte = 1;
                        }
                    };
                    // implement byte stream interface as well
                    this.writeByte = function(_byte) {
                        if (bufferByte === 1) {
                            stream.writeByte(_byte);
                        } else {
                            stream.writeBits(8, _byte);
                        }
                    };
                    this.flush = function() {
                        while (bufferByte !== 1) {
                            this.writeBit(0);
                        }
                        if (stream.flush) { stream.flush(); }
                    };
                })
                    .call(this);
            };
        // inherit read/write methods from Stream.
            BitStream.EOF = Stream.EOF;
            BitStream.prototype = Object.create(Stream.prototype);
        // bit chunk read/write
            BitStream.prototype.readBits = function(n) {
                var i, r = 0
                    , b;
                if (n > 31) {
                    r = this.readBits(n - 16) * 0x10000; // fp multiply, not shift
                    return r + this.readBits(16);
                }
                for (i = 0; i < n; i++) {
                    r <<= 1; // this could make a negative value if n>31
                    // bits read past EOF are all zeros!
                    if (this.readBit() > 0) { r++; }
                }
                return r;
            };
            BitStream.prototype.writeBits = function(n, value) {
                if (n > 32) {
                    var low = (value & 0xFFFF);
                    var high = (value - low) / (0x10000); // fp division, not shift
                    this.writeBits(n - 16, high);
                    this.writeBits(16, low);
                    return;
                }
                var i;
                for (i = n - 1; i >= 0; i--) {
                    this.writeBit((value >>> i) & 1);
                }
            };

            return BitStream;
        }());


        Util = (function(){
            var Util = Object.create(null);

            var EOF = Stream.EOF;

            /* Take a buffer, array, or stream, and return an input stream. $/
            Util.coerceInputStream = function(input, forceRead) {
                if (!('readByte' in input)) {
                    var buffer = input;
                    input = new Stream();
                    input.size = buffer.length;
                    input.pos = 0;
                    input.readByte = function() {
                        if (this.pos >= this.size) { return EOF; }
                        return buffer[this.pos++];
                    };
                    input.read = function(buf, bufOffset, length) {
                        var bytesRead = 0;
                        while (bytesRead < length && this.pos < buffer.length) {
                            buf[bufOffset++] = buffer[this.pos++];
                            bytesRead++;
                        }
                        return bytesRead;
                    };
                    input.seek = function(pos) { this.pos = pos; };
                    input.tell = function() { return this.pos; };
                    input.eof = function() { return this.pos >= buffer.length; };
                } else if (forceRead && !('read' in input)) {
                    // wrap input if it doesn't implement read
                    var s = input;
                    input = new Stream();
                    input.readByte = function() {
                        var ch = s.readByte();
                        if (ch === EOF) { this._eof = true; }
                        return ch;
                    };
                    if ('size' in s) { input.size = s.size; }
                    if ('seek' in s) {
                        input.seek = function(pos) {
                            s.seek(pos); // may throw if s doesn't implement seek
                            this._eof = false;
                        };
                    }
                    if ('tell' in s) {
                        input.tell = s.tell.bind(s);
                    }
                }
                return input;
            };

            var BufferStream = function(buffer, resizeOk) {
                this.buffer = buffer;
                this.resizeOk = resizeOk;
                this.pos = 0;
            };
            BufferStream.prototype = Object.create(Stream.prototype);
            BufferStream.prototype.writeByte = function(_byte) {
                if (this.resizeOk && this.pos >= this.buffer.length) {
                    var newBuffer = Util.makeU8Buffer(this.buffer.length * 2);
                    newBuffer.set(this.buffer);
                    this.buffer = newBuffer;
                }
                this.buffer[this.pos++] = _byte;
            };
            BufferStream.prototype.getBuffer = function() {
                // trim buffer if needed
                if (this.pos !== this.buffer.length) {
                    if (!this.resizeOk)
                        throw new TypeError('outputsize does not match decoded input');
                    var newBuffer = Util.makeU8Buffer(this.pos);
                    newBuffer.set(this.buffer.subarray(0, this.pos));
                    this.buffer = newBuffer;
                }
                return this.buffer;
            };

            /* Take a stream (or not) and an (optional) size, and return an
             * output stream.  Return an object with a 'retval' field equal to
             * the output stream (if that was given) or else a pointer at the
             * internal Uint8Array/buffer/array; and a 'stream' field equal to
             * an output stream to use.
             $/
            Util.coerceOutputStream = function(output, size) {
                var r = { stream: output, retval: output };
                if (output) {
                    if (typeof(output) === 'object' && 'writeByte' in output) {
                        return r; /* leave output alone $/
                    } else if (typeof(size) === 'number') {
                        console.assert(size >= 0);
                        r.stream = new BufferStream(Util.makeU8Buffer(size), false);
                    } else { // output is a buffer
                        r.stream = new BufferStream(output, false);
                    }
                } else {
                    r.stream = new BufferStream(Util.makeU8Buffer(16384), true);
                }
                Object.defineProperty(r, 'retval', {
                    get: r.stream.getBuffer.bind(r.stream)
                });
                return r;
            };

            Util.compressFileHelper = function(magic, guts, suppressFinalByte) {
                return function(inStream, outStream, props) {
                    inStream = Util.coerceInputStream(inStream);
                    var o = Util.coerceOutputStream(outStream, outStream);
                    outStream = o.stream;

                    // write the magic number to identify this file type
                    // (it better be ASCII, we're not doing utf-8 conversion)
                    var i;
                    for (i = 0; i < magic.length; i++) {
                        outStream.writeByte(magic.charCodeAt(i));
                    }

                    // if we know the size, write it
                    var fileSize;
                    if ('size' in inStream && inStream.size >= 0) {
                        fileSize = inStream.size;
                    } else {
                        fileSize = -1; // size unknown
                    }
                    if (suppressFinalByte) {
                        var tmpOutput = Util.coerceOutputStream([]);
                        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
                        tmpOutput = tmpOutput.retval;
                        for (i = 0; i < tmpOutput.length - 1; i++) {
                            outStream.writeByte(tmpOutput[i]);
                        }
                        suppressFinalByte = tmpOutput[tmpOutput.length - 1];
                    } else {
                        Util.writeUnsignedNumber(outStream, fileSize + 1);
                    }

                    // call the guts to do the real compression
                    guts(inStream, outStream, fileSize, props, suppressFinalByte);

                    return o.retval;
                };
            };
            Util.decompressFileHelper = function(magic, guts) {
                return function(inStream, outStream) {
                    inStream = Util.coerceInputStream(inStream);

                    // read the magic number to confirm this file type
                    // (it better be ASCII, we're not doing utf-8 conversion)
                    var i;
                    for (i = 0; i < magic.length; i++) {
                        if (magic.charCodeAt(i) !== inStream.readByte()) {
                            throw new Error("Bad magic");
                        }
                    }

                    // read the file size & create an appropriate output stream/buffer
                    var fileSize = Util.readUnsignedNumber(inStream) - 1;
                    var o = Util.coerceOutputStream(outStream, fileSize);
                    outStream = o.stream;

                    // call the guts to do the real decompression
                    guts(inStream, outStream, fileSize);

                    return o.retval;
                };
            };
        // a helper for simple self-test of model encode
            Util.compressWithModel = function(inStream, fileSize, model) {
                var inSize = 0;
                while (inSize !== fileSize) {
                    var ch = inStream.readByte();
                    if (ch === EOF) {
                        model.encode(256); // end of stream;
                        break;
                    }
                    model.encode(ch);
                    inSize++;
                }
            };
        // a helper for simple self-test of model decode
            Util.decompressWithModel = function(outStream, fileSize, model) {
                var outSize = 0;
                while (outSize !== fileSize) {
                    var ch = model.decode();
                    if (ch === 256) {
                        break; // end of stream;
                    }
                    outStream.writeByte(ch);
                    outSize++;
                }
            };

            /** Write a number using a self-delimiting big-endian encoding. $/
            Util.writeUnsignedNumber = function(output, n) {
                console.assert(n >= 0);
                var bytes = []
                    , i;
                do {
                    bytes.push(n & 0x7F);
                    // use division instead of shift to allow encoding numbers up to
                    // 2^53
                    n = Math.floor(n / 128);
                } while (n !== 0);
                bytes[0] |= 0x80; // mark end of encoding.
                for (i = bytes.length - 1; i >= 0; i--) {
                    output.writeByte(bytes[i]); // write in big-endian order
                }
                return output;
            };

            /** Read a number using a self-delimiting big-endian encoding. $/
            Util.readUnsignedNumber = function(input) {
                var n = 0
                    , c;
                while (true) {
                    c = input.readByte();
                    if (c & 0x80) { n += (c & 0x7F); break; }
                    // using + and * instead of << allows decoding numbers up to 2^53
                    n = (n + c) * 128;
                }
                return n;
            };

        // Compatibility thunks for Buffer/TypedArray constructors.

            var zerofill = function(a) {
                for (var i = 0, len = a.length; i < len; i++) {
                    a[i] = 0;
                }
                return a;
            };

            var fallbackarray = function(size) {
                return zerofill(new Array(size));
            };

        // Node 0.11.6 - 0.11.10ish don't properly zero fill typed arrays.
        // See https://github.com/joyent/node/issues/6664
        // Try to detect and workaround the bug.
            var ensureZeroed = function id(a) { return a; };
            if ((typeof(process) !== 'undefined') &&
                Array.prototype.some.call(new Uint32Array(128), function(x) {
                    return x !== 0;
                })) {
                //console.warn('Working around broken TypedArray');
                ensureZeroed = zerofill;
            }

            /** Portable 8-bit unsigned buffer. $/
            Util.makeU8Buffer = (typeof(Uint8Array) !== 'undefined') ? function(size) {
                // Uint8Array ought to be  automatically zero-filled
                return ensureZeroed(new Uint8Array(size));
            } : (typeof(Buffer) !== 'undefined') ? function(size) {
                var b = new Buffer(size);
                b.fill(0);
                return b;
            } : fallbackarray;

            /** Portable 16-bit unsigned buffer. $/
            Util.makeU16Buffer = (typeof(Uint16Array) !== 'undefined') ? function(size) {
                // Uint16Array ought to be  automatically zero-filled
                return ensureZeroed(new Uint16Array(size));
            } : fallbackarray;

            /** Portable 32-bit unsigned buffer. $/
            Util.makeU32Buffer = (typeof(Uint32Array) !== 'undefined') ? function(size) {
                // Uint32Array ought to be  automatically zero-filled
                return ensureZeroed(new Uint32Array(size));
            } : fallbackarray;

            /** Portable 32-bit signed buffer. $/
            Util.makeS32Buffer = (typeof(Int32Array) !== 'undefined') ? function(size) {
                // Int32Array ought to be  automatically zero-filled
                return ensureZeroed(new Int32Array(size));
            } : fallbackarray;

            Util.arraycopy = function(dst, src) {
                console.assert(dst.length >= src.length);
                for (var i = 0, len = src.length; i < len; i++) {
                    dst[i] = src[i];
                }
                return dst;
            };

            /** Highest bit set in a byte. $/
            var bytemsb = [
                0
                ,1
                ,2, 2
                ,3, 3, 3, 3
                ,4, 4, 4, 4, 4, 4, 4, 4
                ,5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
                ,6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6
                ,7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
                ,8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 /* 256 $/
            ];
            console.assert(bytemsb.length === 0x100);
            /** Find last set (most significant bit).
             *  @return the last bit set in the argument.
             *          <code>fls(0)==0</code> and <code>fls(1)==1</code>. $/
            var fls = Util.fls = function(v) {
                console.assert(v >= 0);
                if (v > 0xFFFFFFFF) { // use floating-point mojo
                    return 32 + fls(Math.floor(v / 0x100000000));
                }
                if ((v & 0xFFFF0000) !== 0) {
                    if ((v & 0xFF000000) !== 0) {
                        return 24 + bytemsb[(v >>> 24) & 0xFF];
                    } else {
                        return 16 + bytemsb[v >>> 16];
                    }
                } else if ((v & 0x0000FF00) !== 0) {
                    return 8 + bytemsb[v >>> 8];
                } else {
                    return bytemsb[v];
                }
            };
            /** Returns ceil(log2(n)) $/
            Util.log2c = function(v) {
                return (v === 0) ? -1 : fls(v - 1);
            };

            return Util; // ensure constants are recognized as such.
        }());


        LogDistanceModel = (function(){
            /** Simple (log n)(n) distance model. $/

        // lengthBitsModelFactory will be called with arguments 2, 4, 8, 16, etc
        // and must return an appropriate model or coder.
            var LogDistanceModel = function(size, extraStates
                , lgDistanceModelFactory
                , lengthBitsModelFactory) {
                var i;
                var bits = Util.fls(size - 1);
                this.extraStates = +extraStates || 0;
                this.lgDistanceModel = lgDistanceModelFactory(1 + bits + extraStates);
                // this.distanceModel[n] used for distances which are n-bits long,
                // but only n-1 bits are encoded: the top bit is known to be one.
                this.distanceModel = [];
                for (i = 2; i <= bits; i++) {
                    var numBits = i - 1;
                    this.distanceModel[i] = lengthBitsModelFactory(1 << numBits);
                }
            };
            /* you can give this model arguments between 0 and (size-1), or else
               a negative argument which is one of the 'extra states'. $/
            LogDistanceModel.prototype.encode = function(distance) {
                if (distance < 2) { // small distance or an 'extra state'
                    this.lgDistanceModel.encode(distance + this.extraStates);
                    return;
                }
                var lgDistance = Util.fls(distance);
                console.assert(distance & (1 << (lgDistance - 1))); // top bit is set
                console.assert(lgDistance >= 2);
                this.lgDistanceModel.encode(lgDistance + this.extraStates);
                // now encode the rest of the bits.
                var rest = distance & ((1 << (lgDistance - 1)) - 1);
                this.distanceModel[lgDistance].encode(rest);
            };
            LogDistanceModel.prototype.decode = function() {
                var lgDistance = this.lgDistanceModel.decode() - this.extraStates;
                if (lgDistance < 2) {
                    return lgDistance; // this is a small distance or an 'extra state'
                }
                var rest = this.distanceModel[lgDistance].decode();
                return (1 << (lgDistance - 1)) + rest;
            };

            return LogDistanceModel;

        }());


        Huffman = (function(){
            /* Adaptive Huffman code, using Vitter's algorithm ported from
             * vitter.c at http://code.google.com/p/compression-code/downloads/list
             * The original code was placed in the public domain, and so I
             * also place this JavaScript port in the public domain.
             *   -- C. Scott Ananian <cscott@cscott.net>, 2013
             * ps. some truly grotty C code in the originally, faithfully ported to
             *     evil comma-operator-using, assignment-in-if-condition JavaScript.
             $/

        //  This code is adapted from Professor Vitter's
        //  article, Design and Analysis of Dynamic Huffman Codes,
        //  which appeared in JACM October 1987

        //  A design trade-off has been made to simplify the
        //  code:  a node's block is determined dynamically,
        //  and the implicit tree structure is maintained,
        //  e.g. explicit node numbers are also implicit.

        //  Dynamic Huffman table weight ranking
        //  is maintained per Professor Vitter's
        //  invariant (*) for algorithm FGK:

        //  leaves precede internal nodes of the
        //  same weight in a non-decreasing ranking
        //  of weights using implicit node numbers:

        //  1) leaves slide over internal nodes, internal nodes
        //  swap over groups of leaves, leaves are swapped
        //  into group leader position, but two internal
        //  nodes never change positions relative
        //  to one another.

        //  2) weights are incremented by 2:
        //  leaves always have even weight values;
        //  internal nodes always have odd values.

        //  3) even node numbers are always right children;
        //  odd numbers are left children in the tree.

        //  node 2 * HuffSize - 1 is always the tree root;
        //  node HuffEsc is the escape node;

        //  the tree is initialized by creating an
        //  escape node as the root.

        //  each new leaf symbol is paired with a new escape
        //  node into the previous escape node in the tree,
        //  until the last symbol which takes over the
        //  tree position of the escape node, and
        //  HuffEsc is left at zero.

        //  overall table size: 2 * HuffSize

        //  huff_init(alphabet_size, potential symbols used)
        //  huff_encode(next_symbol)
        //  next_symbol = huff_decode()

        //  huff_scale(by_bits) -- scale weights and re-balance tree

            var HTable = function(up, down, symbol, weight) {
                this.up = up; // next node up the tree
                this.down = down; // pair of down nodes
                this.symbol = symbol; // node symbol value
                this.weight = weight; // node weight
            };
            HTable.prototype.clone = function() {
                return new HTable(this.up, this.down, this.symbol, this.weight);
            };
            HTable.prototype.set = function(htable) {
                this.up = htable.up;
                this.down = htable.down;
                this.symbol = htable.symbol;
                this.weight = htable.weight;
            };

        //  initialize an adaptive coder
        //  for alphabet size, and count
        //  of nodes to be used
            var Huffman = function(size, root, bitstream, max_weight) {
                var i;
                //  default: all alphabet symbols are used

                console.assert(size && typeof(size) === 'number');
                if (!root || root > size)
                    root = size;

                //  create the initial escape node
                //  at the tree root

                if (root <<= 1) {
                    root--;
                }

                // create root+1 htables (coding table)
                // XXX this could be views on a backing Uint32 array?
                this.table = [];
                for (i = 0; i <= root; i++) {
                    this.table[i] = new HTable(0, 0, 0, 0);
                }

                // this.map => mapping for symbols to nodes
                this.map = [];
                // this.size => the alphabet size
                if (this.size = size) {
                    for (i = 0; i < size; i++) {
                        this.map[i] = 0;
                    }
                }

                // this.esc  => the current tree height
                // this.root => the root of the tree
                this.esc = this.root = root;

                if (bitstream) {
                    this.readBit = bitstream.readBit.bind(bitstream);
                    this.writeBit = bitstream.writeBit.bind(bitstream);
                }
                this.max_weight = max_weight; // may be null or undefined
            }
        // factory interface
            Huffman.factory = function(bitstream, max_weight) {
                return function(size) {
                    return new Huffman(size, size, bitstream, max_weight);
                };
            };


        // split escape node to incorporate new symbol

            Huffman.prototype.split = function(symbol) {
                var pair, node;

                //  is the tree already full???

                if (pair = this.esc) {
                    this.esc--;
                } else {
                    console.assert(false);
                    return 0;
                }

                //  if this is the last symbol, it moves into
                //  the escape node's old position, and
                //  this.esc is set to zero.

                //  otherwise, the escape node is promoted to
                //  parent a new escape node and the new symbol.

                if (node = this.esc) {
                    this.table[pair].down = node;
                    this.table[pair].weight = 1;
                    this.table[node].up = pair;
                    this.esc--;
                } else {
                    pair = 0;
                    node = 1;
                }

                //  initialize the new symbol node

                this.table[node].symbol = symbol;
                this.table[node].weight = 0;
                this.table[node].down = 0;
                this.map[symbol] = node;

                //  initialize a new escape node.

                this.table[this.esc].weight = 0;
                this.table[this.esc].down = 0;
                this.table[this.esc].up = pair;
                return node;
            };

        //  swap leaf to group leader position
        //  return symbol's new node

            Huffman.prototype.leader = function(node) {
                var weight = this.table[node].weight;
                var leader = node
                    , prev, symbol;

                while (weight === this.table[leader + 1].weight) {
                    leader++;
                }

                if (leader === node) {
                    return node;
                }

                // swap the leaf nodes

                symbol = this.table[node].symbol;
                prev = this.table[leader].symbol;

                this.table[leader].symbol = symbol;
                this.table[node].symbol = prev;
                this.map[symbol] = leader;
                this.map[prev] = node;
                return leader;
            };

        //  slide internal node up over all leaves of equal weight;
        //  or exchange leaf with next smaller weight internal node

        //  return node's new position

            Huffman.prototype.slide = function(node) {
                var next = node;
                var swap;

                swap = this.table[next++].clone();

                // if we're sliding an internal node, find the
                // highest possible leaf to exchange with

                if (swap.weight & 1) {
                    while (swap.weight > this.table[next + 1].weight) {
                        next++;
                    }
                }

                //  swap the two nodes

                this.table[node].set(this.table[next]);
                this.table[next].set(swap);

                this.table[next].up = this.table[node].up;
                this.table[node].up = swap.up;

                //  repair the symbol map and tree structure

                if (swap.weight & 1) {
                    this.table[swap.down].up = next;
                    this.table[swap.down - 1].up = next;
                    this.map[this.table[node].symbol] = node;
                } else {
                    this.table[this.table[node].down - 1].up = node;
                    this.table[this.table[node].down].up = node;
                    this.map[swap.symbol] = next;
                }

                return next;
            };

        //  increment symbol weight and re balance the tree.

            Huffman.prototype.increment = function(node) {
                var up;

                //  obviate swapping a parent with its child:
                //    increment the leaf and proceed
                //    directly to its parent.

                //  otherwise, promote leaf to group leader position in the tree

                if (this.table[node].up === node + 1) {
                    this.table[node].weight += 2;
                    node++;
                } else {
                    node = this.leader(node);
                }

                //  increase the weight of each node and slide
                //  over any smaller weights ahead of it
                //  until reaching the root

                //  internal nodes work upwards from
                //  their initial positions; while
                //  symbol nodes slide over first,
                //  then work up from their final
                //  positions.

                while (this.table[node].weight += 2, up = this.table[node].up) {
                    while (this.table[node].weight > this.table[node + 1].weight) {
                        node = this.slide(node);
                    }

                    if (this.table[node].weight & 1) {
                        node = up;
                    } else {
                        node = this.table[node].up;
                    }
                }

                /* Re-scale if necessary. $/
                if (this.max_weight) {
                    if (this.table[this.root].weight >= this.max_weight) {
                        this.scale(1);
                    }
                }
            };

        //  scale all weights and re-balance the tree

        //  zero weight nodes are removed from the tree
        //  by sliding them out the left of the rank list

            Huffman.prototype.scale = function(bits) {
                var node = this.esc
                    , weight, prev;

                //  work up the tree from the escape node
                //  scaling weights by the value of bits

                while (++node <= this.root) {
                    //  recompute the weight of internal nodes;
                    //  slide down and out any unused ones

                    if (this.table[node].weight & 1) {
                        if (weight = this.table[this.table[node].down].weight & ~1) {
                            weight += this.table[this.table[node].down - 1].weight | 1;
                        }

                        //  remove zero weight leaves by incrementing HuffEsc
                        //  and removing them from the symbol map.  take care

                    } else if (!(weight = this.table[node].weight >> bits & ~1)) {
                        if (this.map[this.table[node].symbol] = 0, this.esc++) {
                            this.esc++;
                        }
                    }

                    // slide the scaled node back down over any
                    // previous nodes with larger weights

                    this.table[node].weight = weight;
                    prev = node;

                    while (weight < this.table[--prev].weight) {
                        this.slide(prev);
                    }
                }

                // prepare a new escape node

                this.table[this.esc].down = 0;
            };

        //  send the bits for an escaped symbol

            Huffman.prototype.sendid = function(symbol) {
                var empty = 0
                    , max;

                //  count the number of empty symbols
                //  before the symbol in the table

                while (symbol--) {
                    if (!this.map[symbol]) {
                        empty++;
                    }
                }

                //  send LSB of this count first, using
                //  as many bits as are required for
                //  the maximum possible count

                if (max = this.size - Math.floor((this.root - this.esc) / 2) - 1) {
                    do {
                        this.writeBit(empty & 1);
                        empty >>= 1;
                    } while (max >>= 1);
                }
            };

        //  encode the next symbol

            Huffman.prototype.encode = function(symbol) {
                var emit = 1
                    , bit;
                var up, idx, node;

                if (symbol < this.size) {
                    node = this.map[symbol];
                } else {
                    console.assert(false);
                    return;
                }

                //  for a new symbol, direct the receiver to the escape node
                //  but refuse input if table is already full.

                if (!(idx = node)) {
                    if (!(idx = this.esc)) {
                        return;
                    }
                }

                //  accumulate the code bits by
                //  working up the tree from
                //  the node to the root

                while (up = this.table[idx].up) {
                    emit <<= 1;
                    emit |= idx & 1;
                    idx = up;
                }

                //  send the code, root selector bit first

                while (bit = emit & 1, emit >>= 1) {
                    this.writeBit(bit);
                }

                //  send identification and incorporate
                //  new symbols into the tree

                if (!node) {
                    this.sendid(symbol);
                    node = this.split(symbol);
                }

                //  adjust and re-balance the tree

                this.increment(node);
            };

        //  read the identification bits
        //  for an escaped symbol

            Huffman.prototype.readid = function() {
                var empty = 0
                    , bit = 1
                    , max, symbol;

                //  receive the symbol, LSB first, reading
                //  only the number of bits necessary to
                //  transmit the maximum possible symbol value

                if (max = this.size - Math.floor((this.root - this.esc) / 2) - 1) {
                    do {
                        empty |= this.readBit() ? bit : 0;
                        bit <<= 1;
                    } while (max >>= 1);
                }

                //  the count is of unmapped symbols
                //  in the table before the new one

                for (symbol = 0; symbol < this.size; symbol++) {
                    if (!this.map[symbol]) {
                        if (!empty--) {
                            return symbol;
                        }
                    }
                }

                //  oops!  our count is too big, either due
                //  to a bit error, or a short node count
                //  given to huff_init.

                console.assert(false);
                return 0;
            };

        //  decode the next symbol

            Huffman.prototype.decode = function() {
                var node = this.root;
                var symbol, down;

                //  work down the tree from the root
                //  until reaching either a leaf
                //  or the escape node.  A one
                //  bit means go left, a zero
                //  means go right.

                while (down = this.table[node].down) {
                    if (this.readBit()) {
                        node = down - 1; // the left child precedes the right child
                    } else {
                        node = down;
                    }
                }

                //  sent to the escape node???
                //  refuse to add to a full tree

                if (node === this.esc) {
                    if (this.esc) {
                        symbol = this.readid();
                        node = this.split(symbol);
                    } else {
                        console.assert(false);
                        return 0;
                    }
                } else {
                    symbol = this.table[node].symbol;
                }

                //  increment weights and re-balance
                //  the coding tree

                this.increment(node);
                return symbol;
            };

        // stand alone compressor, mostly for testing
            Huffman.MAGIC = 'huff';
            Huffman.compressFile = Util.compressFileHelper(Huffman.MAGIC, function(input, output, size, props) {
                var bitstream = new BitStream(output);

                var alphabetSize = 256;
                if (size < 0) {
                    alphabetSize++;
                }
                var huff = new Huffman(257, alphabetSize, bitstream, 8191);
                Util.compressWithModel(input, size, huff);
                bitstream.flush();
            });

        // stand alone decompresser, again for testing
            Huffman.decompressFile = Util.decompressFileHelper(Huffman.MAGIC, function(input, output, size) {
                var bitstream = new BitStream(input);

                var alphabetSize = 256;
                if (size < 0) {
                    alphabetSize++;
                }
                var huff = new Huffman(257, alphabetSize, bitstream, 8191);
                Util.decompressWithModel(output, size, huff);
            });

            return Huffman;

        }());


        NoModel = (function(){
            /** Simple "lack of model" -- just encode the bits directly.
             *  Useful especially with sparse spaces or Huffman coders where there's
             *  no obvious prediction to be made that will pay for itself.
             $/

            var NoModel = function(bitstream, size) {
                this.bitstream = bitstream;
                this.bits = Util.fls(size - 1);
            };
            NoModel.factory = function(bitstream) {
                return function(size) { return new NoModel(bitstream, size); };
            };
            NoModel.prototype.encode = function(symbol) {
                var i;
                for (i = this.bits - 1; i >= 0; i--) {
                    var b = (symbol >>> i) & 1;
                    this.bitstream.writeBit(b);
                }
            };
            NoModel.prototype.decode = function() {
                var i, r = 0;
                for (i = this.bits - 1; i >= 0; i--) {
                    r <<= 1;
                    if (this.bitstream.readBit()) r++;
                }
                return r;
            };

            /** Brain-dead self-test. $/
            NoModel.MAGIC = 'nomo';
            NoModel.compressFile = Util.compressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize, props) {
                var bitstream = new BitStream(outStream);
                var model = new NoModel(bitstream, (fileSize < 0) ? 257 : 256);
                Util.compressWithModel(inStream, fileSize, model);
                bitstream.flush();
            });
            NoModel.decompressFile = Util.decompressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize) {
                var bitstream = new BitStream(inStream);
                var model = new NoModel(bitstream, (fileSize < 0) ? 257 : 256);
                Util.decompressWithModel(outStream, fileSize, model);
            });

            return NoModel;


        }());


        FenwickModel = (function(){
            /** Range coding model based on Fenwick trees for O(ln N) query/update. $/

            /** We store two probabilities in a U32, so max prob is going to be 0xFFFF $/
            var DEFAULT_MAX_PROB = 0xFF00;
            var DEFAULT_INCREMENT = 0x0100;

            var ESC_MASK = 0x0000FFFF
                , ESC_SHIFT = 0;
            var SYM_MASK = 0xFFFF0000
                , SYM_SHIFT = 16;
            var SCALE_MASK = 0xFFFEFFFE;

            var FenwickModel = function(coder, size, max_prob, increment) {
                this.coder = coder;
                this.numSyms = size + 1; // save space for an escape symbol
                this.tree = Util.makeU32Buffer(this.numSyms * 2);
                this.increment = (+increment) || DEFAULT_INCREMENT;
                this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;
                // sanity-check to prevent overflow.
                console.assert((this.max_prob + (this.increment - 1)) <= 0xFFFF);
                console.assert(size <= 0xFFFF);
                // record escape probability as 1.
                var i;
                for (i = 0; i < size; i++) {
                    this.tree[this.numSyms + i] = // escape prob=1, sym prob = 0
                        (1 << ESC_SHIFT) | (0 << SYM_SHIFT);
                }
                this.tree[this.numSyms + i] = // escape prob = 0, sym prob = 1
                    (0 << ESC_SHIFT) | (this.increment << SYM_SHIFT);
                this._sumTree();
                // probability sums are in this.tree[1].  this.tree[0] is unused.
            };
            FenwickModel.factory = function(coder, max_prob, increment) {
                return function(size) {
                    return new FenwickModel(coder, size, max_prob, increment);
                };
            };
            FenwickModel.prototype.clone = function() {
                var newModel = new FenwickModel(this.coder, this.size
                    , this.max_prob, this.increment);
                var i;
                for (i = 1; i < this.tree.length; i++) {
                    newModel.tree[i] = this.tree[i];
                }
                return newModel;
            };
            FenwickModel.prototype.encode = function(symbol) {
                var i = this.numSyms + symbol;
                var sy_f = this.tree[i];
                var mask = SYM_MASK
                    , shift = SYM_SHIFT;
                var update = (this.increment << SYM_SHIFT);

                if ((sy_f & SYM_MASK) === 0) { // escape!
                    this.encode(this.numSyms - 1);
                    mask = ESC_MASK;
                    update -= (1 << ESC_SHIFT); // not going to escape no mo'
                    shift = ESC_SHIFT;
                } else if (symbol === (this.numSyms - 1) &&
                    ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {
                    // this is the last escape, zero it out
                    update = -this.tree[i];
                }
                // sum up the proper lt_f
                var lt_f = 0;
                while (i > 1) {
                    var isRight = (i & 1);
                    var parent = (i >>> 1);
                    // if we're the right child, we need to
                    // add the prob from the left child
                    if (isRight) {
                        lt_f += this.tree[2 * parent];
                    }
                    // update sums
                    this.tree[i] += update; // increase sym / decrease esc
                    i = parent;
                }
                var tot_f = this.tree[1];
                this.tree[1] += update; // update prob in root
                sy_f = (sy_f & mask) >>> shift;
                lt_f = (lt_f & mask) >>> shift;
                tot_f = (tot_f & mask) >>> shift;
                this.coder.encodeFreq(sy_f, lt_f, tot_f);
                // rescale?
                if (((this.tree[1] & SYM_MASK) >>> SYM_SHIFT) >= this.max_prob) {
                    this._rescale();
                }
            };
            FenwickModel.prototype._decode = function(isEscape) {
                var mask = SYM_MASK
                    , shift = SYM_SHIFT;
                var update = (this.increment << SYM_SHIFT);
                if (isEscape) {
                    mask = ESC_MASK;
                    update -= (1 << ESC_SHIFT);
                    shift = ESC_SHIFT;
                }
                var tot_f = (this.tree[1] & mask) >>> shift;
                var prob = this.coder.decodeCulFreq(tot_f);
                // travel down the tree looking for this
                var i = 1
                    , lt_f = 0;
                while (i < this.numSyms) {
                    this.tree[i] += update;
                    // look at probability in left child.
                    var leftProb = (this.tree[2 * i] & mask) >>> shift;
                    i *= 2;
                    if ((prob - lt_f) >= leftProb) {
                        lt_f += leftProb;
                        i++; // take the right child.
                    }
                }
                var symbol = i - this.numSyms;
                var sy_f = (this.tree[i] & mask) >>> shift;
                this.tree[i] += update;
                this.coder.decodeUpdate(sy_f, lt_f, tot_f);
                // was this the last escape?
                if (symbol === (this.numSyms - 1) &&
                    ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {
                    update = -this.tree[i]; // zero it out
                    while (i >= 1) {
                        this.tree[i] += update;
                        i = (i >>> 1); // parent
                    }
                }
                // rescale?
                if (((this.tree[1] & SYM_MASK) >>> SYM_SHIFT) >= this.max_prob) {
                    this._rescale();
                }
                return symbol;
            };
            FenwickModel.prototype.decode = function() {
                var symbol = this._decode(false); // not escape
                if (symbol === (this.numSyms - 1)) {
                    // this was an escape!
                    symbol = this._decode(true); // an escape!
                }
                return symbol;
            };
            FenwickModel.prototype._rescale = function() {
                var i, prob, noEscape = true;
                // scale symbols (possible causing them to escape)
                for (i = 0; i < this.numSyms - 1; i++) {
                    prob = this.tree[this.numSyms + i];
                    if ((prob & ESC_MASK) !== 0) {
                        // this symbol escapes
                        noEscape = false;
                        continue;
                    }
                    prob = (prob & SCALE_MASK) >>> 1;
                    if (prob === 0) {
                        // this symbol newly escapes
                        prob = (1 << ESC_SHIFT);
                        noEscape = false;
                    }
                    this.tree[this.numSyms + i] = prob;
                }
                // scale the escape symbol
                prob = this.tree[this.numSyms + i];
                prob = (prob & SCALE_MASK) >>> 1;
                // prob should be zero if there are no escaping symbols, otherwise
                // it must be at least 1.
                if (noEscape) {
                    prob = 0;
                } else if (prob === 0) {
                    prob = (1 << SYM_SHIFT);
                }
                this.tree[this.numSyms + i] = prob;
                // sum it all up afresh
                this._sumTree();
            };
            FenwickModel.prototype._sumTree = function() {
                var i;
                // sum it all. (we know we won't overflow)
                for (i = this.numSyms - 1; i > 0; i--) {
                    this.tree[i] = this.tree[2 * i] + this.tree[2 * i + 1];
                }
            };

            FenwickModel.MAGIC = 'fenw';
            /** Simple order-0 compressor, as self-test. $/
            FenwickModel.compressFile = Util.compressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
                var range = new RangeCoder(outStream);
                range.encodeStart(finalByte, 1);
                var model = new FenwickModel(range, (fileSize < 0) ? 257 : 256);
                Util.compressWithModel(inStream, fileSize, model);
                range.encodeFinish();
            }, true);

            /** Simple order-0 decompresser, as self-test. $/
            FenwickModel.decompressFile = Util.decompressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize) {
                var range = new RangeCoder(inStream);
                range.decodeStart(true /*already read the final byte$/ );
                var model = new FenwickModel(range, (fileSize < 0) ? 257 : 256);
                Util.decompressWithModel(outStream, fileSize, model);
                range.decodeFinish();
            });

            return FenwickModel;

        }());


        DefSumModel = (function(){
            /** Deferred-sum model, suitable for small ( ~ 256 ) ranges. $/
        // See http://cbloom.com/src/defsum.zip
        //     http://cbloom.com/papers/context.pdf

            var LOG_PROB_TOTAL = 8;
            var PROB_TOTAL = 1 << LOG_PROB_TOTAL;
            var MAX_ESCAPE_COUNT = 40;

            var DefSumModel = function(coder, size, isDecoder) {
                var i;
                console.assert(size < 300); // not meant for sparse
                var ESCAPE = this.numSyms = size;
                this.coder = coder;
                this.prob = Util.makeU16Buffer(size + 2); /* size + ESC + 1 $/
                this.escape = Util.makeU16Buffer(size + 1); /* size + 1$/
                this.update = Util.makeU16Buffer(size + 1); /* size + ESC $/
                this.prob[ESCAPE + 1] = PROB_TOTAL;
                for (i = 0; i <= this.numSyms; i++) {
                    this.escape[i] = i;
                }
                this.updateCount = 0;
                this.updateThresh = PROB_TOTAL - Math.floor(PROB_TOTAL / 2);
                if (!isDecoder) {
                    return;
                }
                // extra tables for fast decoding
                this.probToSym = Util.makeU16Buffer(PROB_TOTAL);
                this.escProbToSym = Util.makeU16Buffer(this.numSyms);
                for (i = 0; i < PROB_TOTAL; i++) {
                    this.probToSym[i] = ESCAPE;
                }
                for (i = 0; i < this.numSyms; i++) {
                    this.escProbToSym[i] = i;
                }
            };
            DefSumModel.factory = function(coder, isDecoder) {
                return function(size) {
                    return new DefSumModel(coder, size, isDecoder);
                };
            };
            DefSumModel.prototype._update = function(symbol, isDecoder) {
                if (symbol === this.numSyms) {
                    // some special cases for the escape character
                    if (this.update[symbol] >= MAX_ESCAPE_COUNT) {
                        return;
                    } // hard limit
                    // don't let an escape character trigger an update, because then the
                    // escaped character might find itself unescaped after the tables have
                    // been updated!
                    if (this.updateCount >= (this.updateThresh - 1)) {
                        return;
                    }
                }
                this.update[symbol]++;
                this.updateCount++;
                // is it time to transfer the updated probabilities?
                if (this.updateCount < this.updateThresh) {
                    return; //defer update
                }
                var cumProb, cumEscProb, odd, i, j, k;
                this.escape[0] = this.prob[0] = cumProb = cumEscProb = odd = 0;
                for (i = 0; i < this.numSyms + 1; i++) {
                    var newProb = ((this.prob[i + 1] - this.prob[i]) >>> 1) + this.update[i];
                    if (newProb) {
                        // live 'un
                        this.prob[i] = cumProb;
                        cumProb += newProb;
                        if (newProb & 1) {
                            odd++;
                        }
                        this.escape[i] = cumEscProb;
                    } else {
                        // this symbol will escape
                        this.prob[i] = cumProb;
                        this.escape[i] = cumEscProb;
                        cumEscProb++;
                    }
                }
                this.prob[i] = cumProb;
                console.assert(cumProb === PROB_TOTAL);
                /* how many updates will be required after current probs are halved? $/
                this.updateThresh = PROB_TOTAL - Math.floor((cumProb - odd) / 2);
                /* reset the update table $/
                for (i = 0; i < (this.numSyms + 1); i++) {
                    this.update[i] = 0;
                }
                this.update[this.numSyms] = 1; // ensure that escape never goes away
                this.updateCount = 1;
                /* compute decode table, if this is a decoder $/
                if (!isDecoder) {
                    return;
                }
                for (i = 0, j = 0, k = 0; i < (this.numSyms + 1); i++) {
                    var probLimit = this.prob[i + 1];
                    for (; j < probLimit; j++) {
                        this.probToSym[j] = i;
                    }
                    var escProbLimit = this.escape[i + 1];
                    for (; k < escProbLimit; k++) {
                        this.escProbToSym[k] = i;
                    }
                }
            };
            DefSumModel.prototype.encode = function(symbol) {
                var lt_f = this.prob[symbol];
                var sy_f = this.prob[symbol + 1] - lt_f;
                console.assert(this.prob[this.numSyms + 1] === PROB_TOTAL);
                if (sy_f) {
                    this.coder.encodeShift(sy_f, lt_f, LOG_PROB_TOTAL);
                    return this._update(symbol);
                }
                // escape!
                console.assert(symbol !== this.numSyms); // catch infinite recursion
                this.encode(this.numSyms); // guaranteed non-zero probability
                // code symbol as literal, taking advantage of reduced escape range.
                lt_f = this.escape[symbol];
                sy_f = this.escape[symbol + 1] - lt_f;
                var tot_f = this.escape[this.numSyms];
                this.coder.encodeFreq(sy_f, lt_f, tot_f);
                return this._update(symbol);
            };
            DefSumModel.prototype.decode = function() {
                var prob = this.coder.decodeCulShift(LOG_PROB_TOTAL);
                var symbol = this.probToSym[prob];
                var lt_f = this.prob[symbol];
                var sy_f = this.prob[symbol + 1] - lt_f;
                this.coder.decodeUpdate(sy_f, lt_f, PROB_TOTAL);
                this._update(symbol, true);
                if (symbol !== this.numSyms) {
                    return symbol;
                }
                // escape!
                var tot_f = this.escape[this.numSyms];
                prob = this.coder.decodeCulFreq(tot_f);
                symbol = this.escProbToSym[prob];
                lt_f = this.escape[symbol];
                sy_f = this.escape[symbol + 1] - lt_f;
                this.coder.decodeUpdate(sy_f, lt_f, tot_f);
                this._update(symbol, true);
                return symbol;
            };

            DefSumModel.MAGIC = 'dfsm';
            /** Simple order-0 compressor, as self-test. $/
            DefSumModel.compressFile = Util.compressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
                var range = new RangeCoder(outStream);
                range.encodeStart(finalByte, 1);
                var model = new DefSumModel(range, (fileSize < 0) ? 257 : 256);
                Util.compressWithModel(inStream, fileSize, model);
                range.encodeFinish();
            }, true);
            /** Simple order-0 decompresser, as self-test. $/
            DefSumModel.decompressFile = Util.decompressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize) {
                var range = new RangeCoder(inStream);
                range.decodeStart(true /*already read the final byte$/ );
                var model = new DefSumModel(range, (fileSize < 0) ? 257 : 256, true);
                Util.decompressWithModel(outStream, fileSize, model);
                range.decodeFinish();
            });

            return DefSumModel;

        }());


        Context1Model = (function(){
            /** A simple context-1 model. $/

            var Context1Model = function(modelFactory, contextSize, alphabetSize) {
                var i;
                this.literalModel = [];
                // even if there's an EOF symbol, we don't need a context for it!
                for (i = 0; i < contextSize; i++) {
                    this.literalModel[i] = modelFactory(alphabetSize);
                }
            };
            Context1Model.prototype.encode = function(ch, context) {
                this.literalModel[context].encode(ch);
            };
            Context1Model.prototype.decode = function(context) {
                return this.literalModel[context].decode();
            };

            /** Simple self-test. $/
            Context1Model.MAGIC = 'ctx1';
            Context1Model.compressFile = Util.compressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize, props) {
                var bitstream = new BitStream(outStream);
                var alphabetSize = 256;
                if (fileSize < 0) { alphabetSize++; }
                var coder = Huffman.factory(bitstream, 8191);
                var model = new Context1Model(coder, 256, alphabetSize);
                var lastchar = 0x20;
                var modelp = {
                    encode: function(symbol) {
                        model.encode(symbol, lastchar);
                        lastchar = symbol;
                    }
                };
                Util.compressWithModel(inStream, fileSize, modelp);
                bitstream.flush();
            });
            Context1Model.decompressFile = Util.decompressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize) {
                var bitstream = new BitStream(inStream);
                var alphabetSize = 256;
                if (fileSize < 0) { alphabetSize++; }
                var coder = Huffman.factory(bitstream, 8191);
                var model = new Context1Model(coder, 256, alphabetSize);
                var lastchar = 0x20;
                var modelp = {
                    decode: function() {
                        var symbol = model.decode(lastchar);
                        lastchar = symbol;
                        return symbol;
                    }
                };
                Util.decompressWithModel(outStream, fileSize, modelp);
            });

            return Context1Model;

        }());


        Lzp3 = (function(){
            /* Implementation of LZP3(ish), with an adaptive Huffman code or a range
             * coder (instead of LZP3's original static Huffman code).
             * See: http://www.cbloom.com/papers/lzp.pdf
             $/


            var Lzp3 = Object.create(null);
            Lzp3.MAGIC = 'lzp3';

        // use Huffman coder (fast) or else use range coder (slow)
            var USE_HUFFMAN_CODE = false;
        // use deferred-sum model, which is supposed to be faster (but compresses worse)
            var USE_DEFSUM = false;
        // when to give up attempting to model the length
            var LENGTH_MODEL_CUTOFF = 256;
            var MODEL_MAX_PROB = 0xFF00;
            var MODEL_INCREMENT = 0x100;

        // Constants was used for compress/decompress function.
            var CTXT4_TABLE_SIZE = 1 << 16;
            var CTXT3_TABLE_SIZE = 1 << 12;
            var CTXT2_TABLE_SIZE = 1 << 16;
            var CONTEXT_LEN = 4;
            var LOG_WINDOW_SIZE = 20;
            var WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;
            var MAX_MATCH_LEN = WINDOW_SIZE - 1;
            var MATCH_LEN_CONTEXTS = 16;

            var MAX32 = 0xFFFFFFFF;
            var MAX24 = 0x00FFFFFF;
            var MAX16 = 0x0000FFFF;
            var MAX8 = 0x000000FF;


            var Window = function(maxSize) {
                this.buffer = Util.makeU8Buffer(Math.min(maxSize + 4, WINDOW_SIZE));
                this.pos = 0;
                // context-4 hash table.
                this.ctxt4 = Util.makeU32Buffer(CTXT4_TABLE_SIZE);
                // context-3 hash table
                this.ctxt3 = Util.makeU32Buffer(CTXT3_TABLE_SIZE);
                // context-2 table (not really a hash any more)
                this.ctxt2 = Util.makeU32Buffer(CTXT2_TABLE_SIZE);
                // initial context
                this.put(0x63);
                this.put(0x53);
                this.put(0x61);
                this.put(0x20);
            };
            Window.prototype.put = function(_byte) {
                this.buffer[this.pos++] = _byte;
                if (this.pos >= WINDOW_SIZE) { this.pos = 0; }
                return _byte;
            };
            Window.prototype.get = function(pos) {
                return this.buffer[pos & (WINDOW_SIZE - 1)];
            };
            Window.prototype.context = function(pos, n) {
                var c = 0
                    , i;
                pos = (pos - n) & (WINDOW_SIZE - 1);
                for (i = 0; i < n; i++) {
                    c = (c << 8) | this.buffer[pos++];
                    if (pos >= WINDOW_SIZE) { pos = 0; }
                }
                return c;
            };
        // if matchLen !== 0, update the index; otherwise get index value.
            Window.prototype.getIndex = function(s, matchLen) {
                var c = this.context(s, 4);
                // compute context hashes
                var h4 = ((c >>> 15) ^ c) & (CTXT4_TABLE_SIZE - 1);
                var h3 = ((c >>> 11) ^ c) & (CTXT3_TABLE_SIZE - 1);
                var h2 = c & MAX16;
                // check order-4 context
                var p = 0
                    , checkc;
                // only do context confirmation if matchLen==0 (that is, if we're not just
                // doing an update)
                if (matchLen === 0) {
                    p = this.ctxt4[h4];
                    if (p !== 0 && c !== this.context(p - 1, 4)) {
                        p = 0; // context confirmation failed
                    }
                    if (p === 0) {
                        // check order-3 context
                        p = this.ctxt3[h3];
                        if (p !== 0 && (c & MAX24) !== this.context(p - 1, 3)) {
                            p = 0; // context confirmation failed
                        }
                        if (p === 0) {
                            // check order-2 context
                            p = this.ctxt2[h2];
                            if (p !== 0 && (c && MAX16) !== this.context(p - 1, 2)) {
                                p = 0; // context confirmation failed
                            }
                        }
                    }
                }
                // update context index
                if (matchLen) { matchLen--; }
                this.ctxt4[h4] = this.ctxt3[h3] = this.ctxt2[h2] =
                    (s | (matchLen << LOG_WINDOW_SIZE)) + 1;
                // return lookup result.
                return p;
            };

            /**
             * Compress using modified LZP3 algorithm.  Instead of using static
             * Huffman coding, we use an adaptive Huffman code or range encoding.
             $/
            Lzp3.compressFile = Util.compressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize, props) {
                // sliding window & hash table
                var window = new Window((fileSize >= 0) ? fileSize : WINDOW_SIZE);

                var coderFactory, sparseCoderFactory, flush;

                if (USE_HUFFMAN_CODE) {
                    // Huffman contexts
                    outStream.writeByte(0x80); // mark that this is Huffman coded.
                    var bitstream = new BitStream(outStream);
                    flush = bitstream.flush.bind(bitstream);
                    coderFactory = Huffman.factory(bitstream, MAX16);
                    sparseCoderFactory = NoModel.factory(bitstream);

                } else { // range encoder
                    var range = new RangeCoder(outStream);
                    range.encodeStart(0x00, 0); // 0x00 == range encoded

                    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);
                    if (USE_DEFSUM) {
                        coderFactory = DefSumModel.factory(range, false /* encoder $/ );
                    }
                    // switch sparseCoderFactory to a NoModel when size > cutoff
                    var noCoderFactory = NoModel.factory(range);
                    sparseCoderFactory = function(size) {
                        if (size > LENGTH_MODEL_CUTOFF) {
                            return noCoderFactory(size);
                        }
                        return coderFactory(size);
                    };
                    flush = function() { range.encodeFinish(); };
                }

                var huffLiteral = new Context1Model(coderFactory, 256
                    , (fileSize < 0) ? 257 : 256);
                var huffLen = []
                    , i;
                for (i = 0; i < MATCH_LEN_CONTEXTS; i++) {
                    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN + 1, 1
                        , coderFactory, sparseCoderFactory);
                }

                var inSize = 0
                    , s, matchContext = 0;
                while (inSize !== fileSize) {
                    var ch = inStream.readByte();
                    s = window.pos;
                    var p = window.getIndex(s, 0);
                    if (p !== 0) {
                        // great, a match! how long is it?
                        p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE
                        var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;
                        var matchLen = 0;
                        while (window.get(p + matchLen) === ch && matchLen < MAX_MATCH_LEN) {
                            matchLen++;
                            window.put(ch);
                            ch = inStream.readByte();
                        }
                        // code match length; match len = 0 means "literal"
                        // use "extra state" -1 to mean "same as previous match length"
                        if (prevMatchLen === matchLen) {
                            huffLen[matchContext & (MATCH_LEN_CONTEXTS - 1)].encode(-1);
                        } else {
                            huffLen[matchContext & (MATCH_LEN_CONTEXTS - 1)].encode(matchLen);
                        }
                        // update hash with this match
                        window.getIndex(s, matchLen);
                        inSize += matchLen;
                        matchContext <<= 1;
                        if (matchLen > 0) { matchContext |= 1; }
                        // XXX: LZMA uses a special "delta match" context here if matchLen==0
                        // XXX: it also uses the offset as context for the length (or vice-versa)
                    }
                    // always encode a literal after a match
                    var context1 = window.get(window.pos - 1);
                    if (ch === Stream.EOF) {
                        if (fileSize < 0) {
                            huffLiteral.encode(256, context1);
                        }
                        break;
                    }
                    huffLiteral.encode(ch, context1);
                    window.put(ch);
                    inSize++;
                }
                if (flush) flush();
            });

            /**
             * Decompress using modified LZP3 algorithm.
             $/
            Lzp3.decompressFile = Util.decompressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize) {
                var flags = inStream.readByte();
                var use_huffman_code = !!(flags & 0x80);

                // sliding window & hash table
                var window = new Window((fileSize >= 0) ? fileSize : WINDOW_SIZE);

                var coderFactory, sparseCoderFactory, finish;

                if (use_huffman_code) {
                    // Huffman contexts
                    var bitstream = new BitStream(inStream);
                    coderFactory = Huffman.factory(bitstream, MAX16);
                    sparseCoderFactory = NoModel.factory(bitstream);
                } else { // range encoder
                    var range = new RangeCoder(inStream);
                    range.decodeStart(true /* skip initial read $/ );
                    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);
                    if (USE_DEFSUM) {
                        coderFactory = DefSumModel.factory(range, true /* decoder $/ );
                    }
                    // switch sparseCoderFactory to a NoModel when size > cutoff
                    var noCoderFactory = NoModel.factory(range);
                    sparseCoderFactory = function(size) {
                        if (size > LENGTH_MODEL_CUTOFF) {
                            return noCoderFactory(size);
                        }
                        return coderFactory(size);
                    };
                    finish = function() { range.decodeFinish(); };
                }
        
                var huffLiteral = new Context1Model(coderFactory, 256
                    , (fileSize < 0) ? 257 : 256);
                var huffLen = []
                    , i;
                for (i = 0; i < MATCH_LEN_CONTEXTS; i++) {
                    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN + 1, 1
                        , coderFactory, sparseCoderFactory);
                }
        
                var s, ch, outSize = 0
                    , matchContext = 0;
                while (outSize !== fileSize) {
                    s = window.pos;
                    var p = window.getIndex(s, 0);
                    if (p !== 0) {
                        p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE
                        var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;
                        var matchLen = huffLen[matchContext & (MATCH_LEN_CONTEXTS - 1)].decode();
                        if (matchLen < 0) { matchLen = prevMatchLen; }
                        // copy characters!
                        for (i = 0; i < matchLen; i++) {
                            ch = window.get(p + i);
                            outStream.writeByte(window.put(ch));
                        }
                        window.getIndex(s, matchLen);
                        outSize += matchLen;
                        matchContext <<= 1;
                        if (matchLen > 0) matchContext |= 1;
                    }
                    // literal always follows match (or failed match)
                    if (outSize === fileSize) {
                        break; // EOF
                    }
                    var context1 = window.get(window.pos - 1);
                    ch = huffLiteral.decode(context1);
                    if (ch === 256) {
                        break; // EOF
                    }
                    outStream.writeByte(window.put(ch));
                    outSize++;
                }
                if (finish) finish();
            });
        
        
            return Lzp3;
        }());
        
        if(mode === "COMPRESS_OBJECT") {
            //  JS -> json_str -> ui8a -> compressed ui8a
            resolve(Uint8Array.from(Lzp3.compressFile(new TextEncoder("utf-8").encode(JSON.stringify(uint8a_or_obj, null, 0)))));
            
        }else if(mode === "DECOMPRESS_UINT8A") {
            // ui8a decompressed -> ui8a -> json_str -> JS
            resolve(JSON.parse(new TextDecoder().decode(Uint8Array.from(Lzp3.decompressFile(uint8a_or_obj)))));
            
        }else {
        
            reject(null);
        }
})} */

const LZP3 = async(uint8a_or_obj, mode = "COMPRESS_OBJECT", pool = null) => {

    if(pool !== null) {

        return pool.exec(window.lzp3_json_process_function, [
            uint8a_or_obj,
            mode,
        ]).catch((e) => {

            return window.lzp3_json_process_function(uint8a_or_obj, mode);
        }).timeout(30 * 1000);

    }else {

        return window.lzp3_json_process_function(uint8a_or_obj, mode);
    }
};

module.exports = { LZP3 }
